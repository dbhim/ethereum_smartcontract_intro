Ethereum(эфириум) - платформа на базе блокчейна для выполнения смарт-контрактов.


#### Блокчейн (blockchain)
Блокчейн решает задачу (криптографически) надёжного хранения и обновления некоторых данных (можем назвать это базой данных). Традиционные базы данных умеют решать эти задачи со значительно меньшими накладными расходами. Потому как обычно предполагается их работа на оборудовании одного владельца и с ограничением доступа только для владельца. Т.е. в доверенном (для владельца) окружение происходит хранение и обновление данных. При этом владелец может доверять этим данным настолько насколько он доверяет надёжности своего окружения, а внешние пользователи - насколько они доверяют владельцу. И, вообще говоря, у внешних пользователей нет возможности достоверно убедиться в корректности данных.  
Блокчейн призван решать эту задачу в значительно более сложных условиях. А именно можно выделить следующие особенности:
1) База данных хранится и управляется децентрализованно.
2) Данные (их независимые копии) хранятся открыто и скорее всего на множестве (почти независимых) узлов. 
3) Любой желающий должен иметь возможность проверять корректность выполнения (криптографически стойких) гарантий, предоставляемых архитектурой блокчейна. Для блокчейна это две основные гарантии:
- что данные добавлялись в базу согласно установленной процедуре;
- что внесённые в базу данные не изменялись.
4) Данные могут добавляться в базу (при соблюдении процедур блокчейна) потенциально любым пользователем.
5) Узлы в инфраструктуре блокчейна максимально не доверяют друг другу (при этом доверяют сети в целом).

Для решения изначальной задачи в таких условиях приходится мириться с определёнными особенностями (недостатками):
1) данные могут только добавляться: все внесённые в блокчейн данные остаются в нём навсегда;
2) необходимо синхронизировать копии данных между независимыми узлами;
3) большие накладные расходы;
4) медленная скорость добавления данных.

Эти особенности проистекают из следующей архитектуры.  
Данные добавляются в базу определёнными порциями, называемыми блоками. Каждый блок криптографически связан со всеми предыдущими - хранит хеш предыдущего блока (который хранит хеш своего предыдущего и т.д.). Таким образом, контралирую хеш последнего добавленного блока, можно контролировать целостность всей базы данных. Имеющаяся на узле цепочка блоков определяет его состояние блокчейна. Актуальным состоянием блокчейна во всей сети является согласованная между разными узлами цепочка, которую они готовы считать валидной. Если база статична, относительно несложно добиться согласованного состояния. Основные проблемы возникаются при обновлении базы - добавлении в неё нового блока. Данные для включения в блокчейн могут поставлять любые пользователи. Возникает вопрос, кто будет добавлять новые данные, выбирая что и в каком порядке добавить. Т.е. кто добавит в согласованную цепочку новый блок (сделав новую согласованную цепочку). Так как сеть блокчейна децентрализованная - это не может быть какой-то один главный узел. Иметь право предлагать новый блок должно какое-то множество узлов (можно назвать их узлами консенсуса, майнерами, валидаторами). Стать таким узлом должен иметь возможность (при соблюдении определённых условий) потенциально любой пользователь. Задача валидаторов предлагать новые блоки для включения в блокчейн и в спорных ситуациях определять согласованную валидную цепочку (которая и будет текущим глобальным состоянием блокчейна). Для согласования используется некоторый механизм достижения консенсуса. Этот механизм должен определять что делать в случае наличия нескольких разных цепочек (каждую из которых считает валидной некоторое количество валидаторов). А также определять какие узлы выбирать в качестве валидаторов. Если никаких условий на валидаторов не накладывать, то некто может создать большое число валидаторов и атаковать механизм консенсуса. Обычно требование выражается в наличие определённого количества ресурсов (вычислительных мощностей, денег, репутации, ...), утратой которых валидатор рискует в случае попыток обмана. Это делает подобные атаки на блокчейн экономически невыгодными (а возможно и просто неосуществимыми на практике). Механизм консенсуса proof-of-work в качестве ресурса предполагает вычислительные мощности майнера, заставляя решать сложную задачу. Механизм консенсуса proof-of-stake в качестве ресурса предполагает некоторый денежный эквивалент (обычно в монетах блокчейна).  
В какой-то момент времени отдельные узлы (и подсети) могут хранить состояние, отличное от актуального состояния блокчейна. Но актуальное состояние блокчейна глобально (т.е. не учитывая отдельные узлы с неправильным состоянием) является согласованным. Если какой-то узел в результате консенсуса обнаруживает что его состояние отличается от согласованного актуального состояния, то он должен привести свою цепочку в соответствие с актуальным состоянием.  
В архитектуре блокчейна особенна важна роль сообщества. Предполагается, что есть большое число (например, больше половины) добпропорядочных узлов, которые хранят у себя копию блокчейна (цепочку блоков) и следуют всем протоколам блокчейна. Тогда (относительно) небольшое число злонамеренных узлов не смогут нарушить работу блокчейна.  
Такая архитектура хорошо подходит для хранения транзакций. Например, транзакций модификации базы данных. База данных блокчейна (блоки блокчейна) хранит транзакции, которые формируют некоторую другую базу данных. Она вторична по отношению к блокчейну (так как получается после интерпретации хранимых в блокчейне сущностей), но по сути она часто и хранит основные данные, поэтому её можно назвать основной базой блокчейна (а блоки с транзакциями считать просто техническими деталями).  
Часто при описании блокчейна и эфириума упоминается что это распределённые системы. Что блокчейн - это распределённая база данных, а эфириум - платформа распределённых вычислений. Этот термин может ввести в заблуждение, если трактовать его неправильно (например, распределённые вычисления можно понимать как разбиение большой задачи на подзадачи по разным узлам). Каждый узел независимо от других хранит и обрабатывает данные и смарт-контракты. Совместная работа узлов требуется только во время согласования актуального состояния блокчейна.  
Конкретные блокчейны (например криптовалют) могут добавлять дополнительные правила и проверки при формировании блоков. Например требование проверки корректности включенных в блок транзакций. Тогда от валидаторов требуется выполнение работы по осуществлению этих проверок.  
Таким образом, блокчейн - это идея, позволяющая хранить некоторую базу данных (блоков или базу, получаемую из транзакций в блоках), предоставляя определённые гарантии. А приложения, использующие собственную реализацию блокчейна, наполняют хранимые данные некоторым специфичным смыслом.



#### Эфириум (Ethereum)

[Официальная спецификация](https://ethereum.github.io/yellowpaper/paper.pdf)

Эфириум использует блокчейн для хранения специфичных для своего протокола транзакций. Эти транзакции формируют (по правилам протокола эфириум) актуальное состояние (называемое в документации world state или просто state) базы данных эфириум. В блокчейн транзакции добавляются блоками. Транзакции из блока применяются (каждым узлом сети) к текущему состоянию последовательно (в порядке расположения в блоке), формируя новое состояние.  
В эфириум (и в том числе, для организации блокчейна) используется хеш-функция SHA3(Keccak-256) и ЭЦП ECDSA-secp256k1.  
С 15 сентября 2022 г. эфириум поменял механизм достижения консенсуса для своего блокчейна с proof-of-work на proof-of-stake.  
Основные сущности в эфириум - это учетные записи (account), идентифицируемые 160-битными адресами. Дальше буду называть учётные записи адресами. Состояние эфириум - это просто информация о состоянии каждого (валидного) адреса. По умолчанию все адреса являются (логически) [пустыми](https://eips.ethereum.org/EIPS/eip-161) (хранят нулевое состояние). Валидными они становятся, если в результате транзакции с ними происходит некоторое взаимодействие (перевод денег или создание контракта по адресу).  
Состояние адреса логически включает следующую информацию:
- баланс;
- nonce - монотонно возрастающий счётчик транзакций с этого адреса(для EOA) или созданных контрактов с этого адреса (для адресов кортрактов);
- код/хеш контракта (если есть);
- storage (постоянное хранилище адреса).  
Постоянное хранилище адреса является отображением 256-битных адресов в 256-битные значения.  
Адреса могут быть двух типов (формально они отличаются наличием/отсутствием кода):
- адреса обычных пользователей (EOA);
- адреса контрактов.

Пользователи для работы в эфириум генерируют пару открытого и закрытого ключей для ЭЦП. Адресом пользователя будут являться младшие 160 бит хеша открытого ключа. Т.е. адрес создаётся из ключа и можно проверить соответствие адреса и ключа/подписи. Адреса контрактов генерируются не из ключей. Поэтому (вычислительно) невозможно подобрать соответствующую адресу контракта пару открытого и закрытого ключей.  
Транзакции генерируются пользователем и добавляются в пул (невключённых в блокчейн транзакций), откуда валидаторы добавляют их в некоторый блок. Инициировавший транзакцию пользователь оплачивает её со своего баланса. Транзакция подписывается закрытым ключом пользователя. Транзакции могут быть неуспешными ( заканчиваться с ошибкой). В этом случае изменение состояния не происходит. Но пользователь всё равно оплачивает такую транзакцию, если она включается в блок.  
Транзакции могут быть трёх версий (в документации "types"). А по функциональному назначению делятся на два типа (в документации "subtypes"):
- транзакции, приводящие к передачи сообщения (message call) адресу;
- транзакции, создающие контракт.

Транзакция содержит следующие данные:
- тип;
- nonce - текущий nonce адреса отправителя;
- лимит по газу (gasLimit);
- адрес получателя (to);
- количество пересылаемых монет (value);
- цену газа (gasPrice);
- начальный код (init) - для транзакций создания контракта;
- входные данные (data) - для транзакций передачи сообщения;
- подпись (v, r, s)

Алгоритм ECDSA позволяет по подписываемому сообщению (хеш от подписываемых данных), цифровой подписи (r, s) и дополнительному байтовому идентификатору v восстановить открытый ключ - а значит и адрес отправителя. Поэтому адрес отправителя явно не хранится в транзакции.  
Если в транзакции передачи сообщения адресом получателя является EOA (это адреса, у которых нет кода), происходит простая модификация состояния: указанное количество монет списывается с баланса отправителя и записывается на баланс получателя.  
Отличительной особенностью эфириум является возможность пользователям самостоятельно указывать правила (с определёнными ограничениями) модификации состояния. Это делается с помощью контрактов (смарт-контрактов). Контракты создаются в результате успешной транзакции типа создания контракта. В поле init которой передаётся некоторый начальный код (массив байт), который должен вернуть код (массив байт), который сохраняется в постоянном хранилище кода, связанном с адресом.  
Код контракта представляет собой байткод для виртуальной машины эфириум (EVM). EVM - это специализированная для смарт-контрактов стек-машина. Каждая [инструкция](https://www.ethervm.io/#opcodes) EVM имеет определённую (фиксированную или [динамическую](https://github.com/wolflo/evm-opcodes/blob/main/gas.md)) стоимость в единицах газа (gas). Суммарная стоимость всех выполненных инструкций не должна превышать лимита по газу, установленного в транзакции. Иначе транзакция заканчивается с ошибкой. Исполнение кода может заканчиваться с помощью специальных инструкций: в зависимости от инструкций это может быть успешное или ошибочное завершение вызова. В случае успешного завершения код контракта может возвращать значение (массив байт).  
Передача сообщения адресу контракта (а не EOA) будет приводить не просто к изменению баланса, а к вызову кода контракта. Исполняющийся код контракта может изменять состояние, выполняя следующие действия:
- записывая данные в постоянное хранилище (storage) адреса контракта;
- переводя деньги с адреса контракта на некоторый другой адрес через передачу сообщения (с ненулевым value) этому адресу.

Создание внутри контракта нового контракта возможно с помощью двух инструкций `create`, `create2`. При этом вычисляется адрес нового контракта и проверяется, что по этому адресу ничего нет.
Для инструкции `create` адрес нового контракта получается как `hash(sender, nonce)`. Для инструкции `create2` - `hash(0xFF, sender, salt, bytecode)`. Т.е. для `create2` возможно создавать контракт с заранее известным адресом. 

Транзакция передачи сообщения к адресу контракта приводит к вызову кода контракта. А исполняющийся код контракта может передавать сообщения другим контрактам - т.е. вызывать их код. Вызывать можно любой существущий в эфириум контракт - нужен только его адрес (а адреса всех контрактов публично доступны). По некоторым фиксированным адресам (начиная с 1) располагаются [предкомпилированные контракты](https://github.com/wolflo/evm-opcodes/blob/main/precompiles.md), которые выполняют некоторую стандартную функциональность: проверка цифровой подписи (ecrecover), вычисление хеша и др.  
Транзакция (передачи сообщения) от пользователя к контракту приводит к вызову кода контракта. Контракт может посылать сообщения (вызывать) другие контракты (через инструкции `call`, `staticcall`, `delegatecall`). При каждом вызове контракта указывается максимальное количество газа, которое может быть потрачено до возврата из этого вызова (т.е. на код вызванного контракта и код других контрактов, которые могут быть при этом вызваны). Транзакция к контракту инициирует первый вызов (в цепочке вызовов), лимит по газу для которого устанавливается в поле транзакции. Все дальнейшие вызовы (в рамках этой транзакции) происходят из исполняющегося кода: контракты вызывают другие контракты. При этом явно можно указать количество газа на новый вызов, оно не может превышать оставшееся (для текущего вызова) количество газа. Если явно не указать количество газа, то в новый вызов передаётся осташееся (в текущем вызове) количество газа.  
Инструкция `call` вызывает другой контракт со сменой состояния (storage, msg). Инструкция `staticcall` аналогична `call`, только в её вызове (и всех возможных подвызовах) запрещено изменение состояния. Инструкция `delegatecall` вызывает другой контракт без смены состояния.  
Вызов кода контракта может закончится неудачно: закончится газ или выполнится инструкция revert. В этом случае отбрасываются все изменения состояния, которые были в этом неудачном вызове, и в вызвавший код возвращается false. Если ошибкой заканчивается самый первый вызов (инициированный транзакцией), то с ошибкой завершается вся транзакция и откатываются изменения всех (возможно и удачных) подвызовов.

Единственный (за небольшим исключением) способ передать монеты с адреса на адрес (EOA или контракта) - сделать передачу сообщения с ненулевым значением `value`. Это можно сделать через транзакцию передачи сообщения. В этом случае адресом будет являться EOA или адрес контракта. Для контракта передачу сообщения (с ненулевым `value`) можно ещё сделать через инструкцию `call` из другого контракта. Монеты, пришедшие на контракт, сразу же зачисляются на его баланс и могут быть переведены в рамках этого же вызова другому контракту. Состояние контракта не предполагает возможности запретить перевод денег контракту. Но, так как передача осуществляется через вызов кода контракта, то этот код может проверить значение `value` и сделать `revert` в случае перевода (для EOA такой возможности нет). Но есть ещё возможность переводить монеты через инструкцию `selfdestruct`, которая удаляет контракт (с форка Cancun уже нет) и переводит его монеты на указанный адрес. При этом код контракта не вызывается и перевод запретить нельзя.  

Код контракта (или множества связанных контрактов) реализует некоторую логику. В совокупности с возможностью использования внутренней валюты эфириума (эфира) это позволяет реализовывать всевозможные финансовые приложения (DeFi). Логика приложения может быть полностью реализована в коде контракта. Или же разделяться между кодом контракта и кодом за пределами эфириума (который обращается к коду контракта с помощью транзакций). Код, реализованный в контракте, выступает некоторой точкой доверия, так как доступен всем (часто с исходным кодом) и не может быть изменён (за некоторым известным исключением). При определённых условиях это позволяет убедиться, что заявленная функциональность будет гарантированно выполнена.  
Популярными являются контракты токенов (ERC-20). Например, [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7).