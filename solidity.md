Solidity

В данном описании я постараюсь подчеркнуть какие-то неочевидные моменты. Основную информацию следует получить из кода примеров. А за специфичной информацией следует обращаться к официальной документации.

Язык Solidity позволяет писать код на высокоуровневом языке, скрывая от нас низкоуровневые детали функционирования EVM, деплоя контракта, вызова кода контракта (реализуя свой [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html). Описание EVM следует прочитать в [другом документе](./ethereum_intro.md). Здесь же будут описаны абстрации, которые Solidity выстраивает поверх EVM.  
Компилятор генерирует начальный код деплоя, в котором вызывается код инициализации от компилятора и код конструктора. Также генерируется код, который осуществляет диспетчеризацию по пользовательским функциям. При передаче сообщения контракту (вызове контракта) EVM просто передаёт управление на начало байткода, ничего не зная функциональной декомпозиции кода контракта. Код, добавленный компилятором, как раз на основе переданных данных определяет код какой функции вызвать. Для этого используется селектор - младшие 4 байт от хеша сигнатуры функции. Согласно [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector-and-argument-encoding) селектор передаётся в первых 4-х байтах входных данных (calldata), а затем аргументы функции.

Базовым местом для описания функциональности является контракт ([contract](https://docs.soliditylang.org/en/develop/structure-of-a-contract.html)).  
У монтракта могут быть переменные в постоянном хранилище (storage) и методы с различными уровнями доступности, определяемыми модификаторами доступа (`public`, `private`, `external`, `internal`).  
Есть возможность наследования (в том числе множественного) со статическим полиморфизмом.  
Доступ внутри контракта к его переменным и функциями возможен как непосредственно по имени (internal access - внутренний вызов), так и через `this.` (external access - внешний вызов). Внешний вызов предполагает отправку сообщения.  
Переменные, объявленные внутри контракта вне функций, располагаются в постоянном хранилище. Компилятор распределяет (в порядке объявления) переменные по (256-битным) слотам постоянного хранилища (начиная с 0 адреса).  
При объявлении таких переменных можно задать им значения. Эти значения будут записаны в постоянное хранилище во время инициализации контракта сгенерированным компилятором кодом. Также во время инициализации будет вызван реализованный программистом конструктор. При создании контракта в вызов конструктора можно передать аргументы.  
При объявлении переменных можно пометить их модификаторами константности:
- `constant`	- инициализация константой времени выполнения
- `immutable`	- значение инициализации может быть сформировано во время иницилизации контракта (в конструкторе)
Стоит отметить, что эта константность только на уровне языка solidity - на уровне EVM нет ограничений на возможность перезаписи значений в постоянном хранилище.

[Модификаторы доступа](https://docs.soliditylang.org/en/develop/contracts.html#state-variable-visibility) для переменных в постоянном хранилище:
- `private`	- доступ только из самого контракта
- `internal`	- доступ из самого контракта и дочерних
- `public`	- дополнительно предоставляет возможность доступа из других контрактов через автоматически сгенерированный геттер.  
Данные, используемые в коде (в виде переменных или аргументов), могут быть расположены в [разных местах](https://docs.soliditylang.org/en/develop/types.html#data-location):
- в стеке (в solidity непосредственно не видны);
- в постоянном хранилище (`storage`);
- в памяти (`memory`);
- в аргументах сообщения (`calldata`).\
Соответствующим ключевым словом следует указывать место расположения локальных переменных и аргументов функций. Для доступа к ним используются разные инструкции EVM: `PUSH`/`POP`, `SLOAD`/`SSTORE`, `MLOAD`/`MSTORE`, `CALLDATALOAD`/`CALLDATASIZE`/`CALLDATACOPY` - поэтому должен генерироваться разный код.  
Кроме хранения это определяет ещё и [поведение при присваивании](https://docs.soliditylang.org/en/develop/types.html#data-location-and-assignment-behavior) (создаётся копия или ссылка)

[Модификаторы доступа](https://docs.soliditylang.org/en/develop/contracts.html#function-visibility) для функций контракта:
- `external`	- доступ через отправку сообщения (через транзакцию, из других контрактов, внешний вызов из самого контракта);
- `public`	- доступ через отправку сообщения или локально;
- `internal`	- доступ возможен только через внутренний вызов из самого контракта или дочернего;
- `private`	- доступ возможен только через внутренний вызов из самого контракта;

Также модификаторы функции могут определять работу с постоянным хранилищем:
- `pure`	- не обращаются к постоянному хранилищу;
- `view`	- может только читать из постоянного хранилища.

Если модификатор не указан, то с постоянным хранилищем возможны операции чтения и записи.  
Если при вызове функции (при передачи сообщения контракту) предполагается передача эфира (value > 0), то функция должна быть помечена модификатором `payable`.

Функции родительских классов могут быть переопределены в дочерних. Для этого в базовом они помечаются модификатором `virtual`, в дочернем - `override`.

Контракт, который не предназначен для непосредственного деплоя (а только выступает в качестве родительского класса), может быть помечен как абстрактный ([`abstract contract`](https://docs.soliditylang.org/en/develop/contracts.html#abstract-contracts)). В абстрактном контракте могут быть виртуальные функции без реализации - они должны быть переопределены (`override`) в дочернем классе.

Вызов функций из других контрактов осуществляется через отправку сообщений. Функция определяется 4-х байтным селектором. Т.е. для доступа к функциям другого контракта достаточно знать только их сигнатуры. Сигнатура функций контракта может быть описана в сущности, называемой интерфейсом ([`interface`](https://docs.soliditylang.org/en/develop/contracts.html#interfaces)). Фактически это объявление контракта без определений функций. В коде любой адрес можно привести к типу интерфейса или контракта и вызывать методы как для обычного контракта. Адрес можно привести и к неправильному типу (не соответствующему фактическому) - после приведения доступ будет возможен только к тем функциям, у которых совпадают сигнатуры в обоих типа (интерфейсах). При вызове в контракте функции с недействительным селектором, будет вызвана функция `fallback`.

Solidity поддерживает особый тип - адрес (`address`). [Доступные методы](https://docs.soliditylang.org/en/develop/units-and-global-variables.html#members-of-address-types) для типа адреса:
- `balance(uint256)`
- `code(bytes memory)`
- `codehash(bytes32)`
- `transfer(uint256 amount)`	- передаёт эфир с контракта на адрес, в случае ошибки - `revert`.
- `send(uint256 amount) returns (bool)` передаёт эфир с контракта на адрес, в случае ошибки - возвращает `false`.
- `call(bytes memory) returns (bool, bytes memory)`
- `delegatecall(bytes memory) returns (bool, bytes memory)`
- `staticcall(bytes memory) returns (bool, bytes memory)`

Если на адрес предполагается передача эфира (через отправку сообщения), то тип должен быть `address payable`. Можно [перевести деньги](https://solidity-by-example.org/sending-ether/) другому контракту, указав `value` при вызове любой функции. Но также есть специальные методы адреса: `send`, `transfer`. Они делают вызов по указанному адресу с пустым селектором - в этом случае вызывается специальная функция `receive` вызываемого контракта (если она определена), в вызов передаётся указанное количество монет и небольшое фиксированное количество газа. Если вызов функции заканчивается с ошибкой (`call` возвращает `false`), то в случае `transfer` выполняется (после проверки кода возрата из `call`) `revert`.

EVM не предполагает завершения вызова/транзакции с ошибкой при каких-то неправильных действиях (например ошибка внутри вызова `call`). Вызов может завершиться с ошибкой только если закончился газ или в случае явного вызова `revert`. Solidity для каких-то своих абстракций может добавлять завершение с ошибкой в каких-то ситуациях - для этого компилятором добавляется код проверки и явный вызов `revert` в случае ошибки. Примерами таких ситуаций являются: `transfer`, проверка на переполнение для целочисленных типов, выход за пределы массива, отправка монет функциям без модификатора payable.

EVM поддерживает специальные инструкции для получения информации о транзакции, блоке, сообщении. Доступ к этой информации в Solidity предоставляется через [встроенные идентификаторы](https://docs.soliditylang.org/en/develop/units-and-global-variables.html) `tx`, `msg`, `block`, `blockhash`, `gasleft`.

Solidity предоставляет возможность писать код на более низкоуровневом языке [Yul](https://docs.soliditylang.org/en/develop/assembly.html) в отдельном блоке `assembly { ... }`. Его можно воспринимать как высокоуровневый язык ассемблера.

[Замечания по безопасности](https://docs.soliditylang.org/en/latest/security-considerations.html).